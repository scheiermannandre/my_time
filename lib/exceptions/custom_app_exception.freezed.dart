// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'custom_app_exception.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$CustomAppException {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() entryNotFound,
    required TResult Function() timeRangesOverlap,
    required TResult Function() projectNotFound,
    required TResult Function() groupNotFound,
    required TResult Function() multipleTimerStarts,
    required TResult Function() timerDataNotFound,
    required TResult Function(String status) unexpected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? entryNotFound,
    TResult? Function()? timeRangesOverlap,
    TResult? Function()? projectNotFound,
    TResult? Function()? groupNotFound,
    TResult? Function()? multipleTimerStarts,
    TResult? Function()? timerDataNotFound,
    TResult? Function(String status)? unexpected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? entryNotFound,
    TResult Function()? timeRangesOverlap,
    TResult Function()? projectNotFound,
    TResult Function()? groupNotFound,
    TResult Function()? multipleTimerStarts,
    TResult Function()? timerDataNotFound,
    TResult Function(String status)? unexpected,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntryNotFound value) entryNotFound,
    required TResult Function(TimeRangesOverlap value) timeRangesOverlap,
    required TResult Function(ProjectNotFound value) projectNotFound,
    required TResult Function(GroupNotFound value) groupNotFound,
    required TResult Function(MultipleTimerStarts value) multipleTimerStarts,
    required TResult Function(TimerDataNotFound value) timerDataNotFound,
    required TResult Function(Unexpected value) unexpected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntryNotFound value)? entryNotFound,
    TResult? Function(TimeRangesOverlap value)? timeRangesOverlap,
    TResult? Function(ProjectNotFound value)? projectNotFound,
    TResult? Function(GroupNotFound value)? groupNotFound,
    TResult? Function(MultipleTimerStarts value)? multipleTimerStarts,
    TResult? Function(TimerDataNotFound value)? timerDataNotFound,
    TResult? Function(Unexpected value)? unexpected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntryNotFound value)? entryNotFound,
    TResult Function(TimeRangesOverlap value)? timeRangesOverlap,
    TResult Function(ProjectNotFound value)? projectNotFound,
    TResult Function(GroupNotFound value)? groupNotFound,
    TResult Function(MultipleTimerStarts value)? multipleTimerStarts,
    TResult Function(TimerDataNotFound value)? timerDataNotFound,
    TResult Function(Unexpected value)? unexpected,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CustomAppExceptionCopyWith<$Res> {
  factory $CustomAppExceptionCopyWith(
          CustomAppException value, $Res Function(CustomAppException) then) =
      _$CustomAppExceptionCopyWithImpl<$Res, CustomAppException>;
}

/// @nodoc
class _$CustomAppExceptionCopyWithImpl<$Res, $Val extends CustomAppException>
    implements $CustomAppExceptionCopyWith<$Res> {
  _$CustomAppExceptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EntryNotFoundImplCopyWith<$Res> {
  factory _$$EntryNotFoundImplCopyWith(
          _$EntryNotFoundImpl value, $Res Function(_$EntryNotFoundImpl) then) =
      __$$EntryNotFoundImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EntryNotFoundImplCopyWithImpl<$Res>
    extends _$CustomAppExceptionCopyWithImpl<$Res, _$EntryNotFoundImpl>
    implements _$$EntryNotFoundImplCopyWith<$Res> {
  __$$EntryNotFoundImplCopyWithImpl(
      _$EntryNotFoundImpl _value, $Res Function(_$EntryNotFoundImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EntryNotFoundImpl implements EntryNotFound {
  const _$EntryNotFoundImpl();

  @override
  String toString() {
    return 'CustomAppException.entryNotFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EntryNotFoundImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() entryNotFound,
    required TResult Function() timeRangesOverlap,
    required TResult Function() projectNotFound,
    required TResult Function() groupNotFound,
    required TResult Function() multipleTimerStarts,
    required TResult Function() timerDataNotFound,
    required TResult Function(String status) unexpected,
  }) {
    return entryNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? entryNotFound,
    TResult? Function()? timeRangesOverlap,
    TResult? Function()? projectNotFound,
    TResult? Function()? groupNotFound,
    TResult? Function()? multipleTimerStarts,
    TResult? Function()? timerDataNotFound,
    TResult? Function(String status)? unexpected,
  }) {
    return entryNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? entryNotFound,
    TResult Function()? timeRangesOverlap,
    TResult Function()? projectNotFound,
    TResult Function()? groupNotFound,
    TResult Function()? multipleTimerStarts,
    TResult Function()? timerDataNotFound,
    TResult Function(String status)? unexpected,
    required TResult orElse(),
  }) {
    if (entryNotFound != null) {
      return entryNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntryNotFound value) entryNotFound,
    required TResult Function(TimeRangesOverlap value) timeRangesOverlap,
    required TResult Function(ProjectNotFound value) projectNotFound,
    required TResult Function(GroupNotFound value) groupNotFound,
    required TResult Function(MultipleTimerStarts value) multipleTimerStarts,
    required TResult Function(TimerDataNotFound value) timerDataNotFound,
    required TResult Function(Unexpected value) unexpected,
  }) {
    return entryNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntryNotFound value)? entryNotFound,
    TResult? Function(TimeRangesOverlap value)? timeRangesOverlap,
    TResult? Function(ProjectNotFound value)? projectNotFound,
    TResult? Function(GroupNotFound value)? groupNotFound,
    TResult? Function(MultipleTimerStarts value)? multipleTimerStarts,
    TResult? Function(TimerDataNotFound value)? timerDataNotFound,
    TResult? Function(Unexpected value)? unexpected,
  }) {
    return entryNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntryNotFound value)? entryNotFound,
    TResult Function(TimeRangesOverlap value)? timeRangesOverlap,
    TResult Function(ProjectNotFound value)? projectNotFound,
    TResult Function(GroupNotFound value)? groupNotFound,
    TResult Function(MultipleTimerStarts value)? multipleTimerStarts,
    TResult Function(TimerDataNotFound value)? timerDataNotFound,
    TResult Function(Unexpected value)? unexpected,
    required TResult orElse(),
  }) {
    if (entryNotFound != null) {
      return entryNotFound(this);
    }
    return orElse();
  }
}

abstract class EntryNotFound implements CustomAppException {
  const factory EntryNotFound() = _$EntryNotFoundImpl;
}

/// @nodoc
abstract class _$$TimeRangesOverlapImplCopyWith<$Res> {
  factory _$$TimeRangesOverlapImplCopyWith(_$TimeRangesOverlapImpl value,
          $Res Function(_$TimeRangesOverlapImpl) then) =
      __$$TimeRangesOverlapImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TimeRangesOverlapImplCopyWithImpl<$Res>
    extends _$CustomAppExceptionCopyWithImpl<$Res, _$TimeRangesOverlapImpl>
    implements _$$TimeRangesOverlapImplCopyWith<$Res> {
  __$$TimeRangesOverlapImplCopyWithImpl(_$TimeRangesOverlapImpl _value,
      $Res Function(_$TimeRangesOverlapImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TimeRangesOverlapImpl implements TimeRangesOverlap {
  const _$TimeRangesOverlapImpl();

  @override
  String toString() {
    return 'CustomAppException.timeRangesOverlap()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TimeRangesOverlapImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() entryNotFound,
    required TResult Function() timeRangesOverlap,
    required TResult Function() projectNotFound,
    required TResult Function() groupNotFound,
    required TResult Function() multipleTimerStarts,
    required TResult Function() timerDataNotFound,
    required TResult Function(String status) unexpected,
  }) {
    return timeRangesOverlap();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? entryNotFound,
    TResult? Function()? timeRangesOverlap,
    TResult? Function()? projectNotFound,
    TResult? Function()? groupNotFound,
    TResult? Function()? multipleTimerStarts,
    TResult? Function()? timerDataNotFound,
    TResult? Function(String status)? unexpected,
  }) {
    return timeRangesOverlap?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? entryNotFound,
    TResult Function()? timeRangesOverlap,
    TResult Function()? projectNotFound,
    TResult Function()? groupNotFound,
    TResult Function()? multipleTimerStarts,
    TResult Function()? timerDataNotFound,
    TResult Function(String status)? unexpected,
    required TResult orElse(),
  }) {
    if (timeRangesOverlap != null) {
      return timeRangesOverlap();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntryNotFound value) entryNotFound,
    required TResult Function(TimeRangesOverlap value) timeRangesOverlap,
    required TResult Function(ProjectNotFound value) projectNotFound,
    required TResult Function(GroupNotFound value) groupNotFound,
    required TResult Function(MultipleTimerStarts value) multipleTimerStarts,
    required TResult Function(TimerDataNotFound value) timerDataNotFound,
    required TResult Function(Unexpected value) unexpected,
  }) {
    return timeRangesOverlap(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntryNotFound value)? entryNotFound,
    TResult? Function(TimeRangesOverlap value)? timeRangesOverlap,
    TResult? Function(ProjectNotFound value)? projectNotFound,
    TResult? Function(GroupNotFound value)? groupNotFound,
    TResult? Function(MultipleTimerStarts value)? multipleTimerStarts,
    TResult? Function(TimerDataNotFound value)? timerDataNotFound,
    TResult? Function(Unexpected value)? unexpected,
  }) {
    return timeRangesOverlap?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntryNotFound value)? entryNotFound,
    TResult Function(TimeRangesOverlap value)? timeRangesOverlap,
    TResult Function(ProjectNotFound value)? projectNotFound,
    TResult Function(GroupNotFound value)? groupNotFound,
    TResult Function(MultipleTimerStarts value)? multipleTimerStarts,
    TResult Function(TimerDataNotFound value)? timerDataNotFound,
    TResult Function(Unexpected value)? unexpected,
    required TResult orElse(),
  }) {
    if (timeRangesOverlap != null) {
      return timeRangesOverlap(this);
    }
    return orElse();
  }
}

abstract class TimeRangesOverlap implements CustomAppException {
  const factory TimeRangesOverlap() = _$TimeRangesOverlapImpl;
}

/// @nodoc
abstract class _$$ProjectNotFoundImplCopyWith<$Res> {
  factory _$$ProjectNotFoundImplCopyWith(_$ProjectNotFoundImpl value,
          $Res Function(_$ProjectNotFoundImpl) then) =
      __$$ProjectNotFoundImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProjectNotFoundImplCopyWithImpl<$Res>
    extends _$CustomAppExceptionCopyWithImpl<$Res, _$ProjectNotFoundImpl>
    implements _$$ProjectNotFoundImplCopyWith<$Res> {
  __$$ProjectNotFoundImplCopyWithImpl(
      _$ProjectNotFoundImpl _value, $Res Function(_$ProjectNotFoundImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ProjectNotFoundImpl implements ProjectNotFound {
  const _$ProjectNotFoundImpl();

  @override
  String toString() {
    return 'CustomAppException.projectNotFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ProjectNotFoundImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() entryNotFound,
    required TResult Function() timeRangesOverlap,
    required TResult Function() projectNotFound,
    required TResult Function() groupNotFound,
    required TResult Function() multipleTimerStarts,
    required TResult Function() timerDataNotFound,
    required TResult Function(String status) unexpected,
  }) {
    return projectNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? entryNotFound,
    TResult? Function()? timeRangesOverlap,
    TResult? Function()? projectNotFound,
    TResult? Function()? groupNotFound,
    TResult? Function()? multipleTimerStarts,
    TResult? Function()? timerDataNotFound,
    TResult? Function(String status)? unexpected,
  }) {
    return projectNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? entryNotFound,
    TResult Function()? timeRangesOverlap,
    TResult Function()? projectNotFound,
    TResult Function()? groupNotFound,
    TResult Function()? multipleTimerStarts,
    TResult Function()? timerDataNotFound,
    TResult Function(String status)? unexpected,
    required TResult orElse(),
  }) {
    if (projectNotFound != null) {
      return projectNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntryNotFound value) entryNotFound,
    required TResult Function(TimeRangesOverlap value) timeRangesOverlap,
    required TResult Function(ProjectNotFound value) projectNotFound,
    required TResult Function(GroupNotFound value) groupNotFound,
    required TResult Function(MultipleTimerStarts value) multipleTimerStarts,
    required TResult Function(TimerDataNotFound value) timerDataNotFound,
    required TResult Function(Unexpected value) unexpected,
  }) {
    return projectNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntryNotFound value)? entryNotFound,
    TResult? Function(TimeRangesOverlap value)? timeRangesOverlap,
    TResult? Function(ProjectNotFound value)? projectNotFound,
    TResult? Function(GroupNotFound value)? groupNotFound,
    TResult? Function(MultipleTimerStarts value)? multipleTimerStarts,
    TResult? Function(TimerDataNotFound value)? timerDataNotFound,
    TResult? Function(Unexpected value)? unexpected,
  }) {
    return projectNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntryNotFound value)? entryNotFound,
    TResult Function(TimeRangesOverlap value)? timeRangesOverlap,
    TResult Function(ProjectNotFound value)? projectNotFound,
    TResult Function(GroupNotFound value)? groupNotFound,
    TResult Function(MultipleTimerStarts value)? multipleTimerStarts,
    TResult Function(TimerDataNotFound value)? timerDataNotFound,
    TResult Function(Unexpected value)? unexpected,
    required TResult orElse(),
  }) {
    if (projectNotFound != null) {
      return projectNotFound(this);
    }
    return orElse();
  }
}

abstract class ProjectNotFound implements CustomAppException {
  const factory ProjectNotFound() = _$ProjectNotFoundImpl;
}

/// @nodoc
abstract class _$$GroupNotFoundImplCopyWith<$Res> {
  factory _$$GroupNotFoundImplCopyWith(
          _$GroupNotFoundImpl value, $Res Function(_$GroupNotFoundImpl) then) =
      __$$GroupNotFoundImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GroupNotFoundImplCopyWithImpl<$Res>
    extends _$CustomAppExceptionCopyWithImpl<$Res, _$GroupNotFoundImpl>
    implements _$$GroupNotFoundImplCopyWith<$Res> {
  __$$GroupNotFoundImplCopyWithImpl(
      _$GroupNotFoundImpl _value, $Res Function(_$GroupNotFoundImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GroupNotFoundImpl implements GroupNotFound {
  const _$GroupNotFoundImpl();

  @override
  String toString() {
    return 'CustomAppException.groupNotFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GroupNotFoundImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() entryNotFound,
    required TResult Function() timeRangesOverlap,
    required TResult Function() projectNotFound,
    required TResult Function() groupNotFound,
    required TResult Function() multipleTimerStarts,
    required TResult Function() timerDataNotFound,
    required TResult Function(String status) unexpected,
  }) {
    return groupNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? entryNotFound,
    TResult? Function()? timeRangesOverlap,
    TResult? Function()? projectNotFound,
    TResult? Function()? groupNotFound,
    TResult? Function()? multipleTimerStarts,
    TResult? Function()? timerDataNotFound,
    TResult? Function(String status)? unexpected,
  }) {
    return groupNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? entryNotFound,
    TResult Function()? timeRangesOverlap,
    TResult Function()? projectNotFound,
    TResult Function()? groupNotFound,
    TResult Function()? multipleTimerStarts,
    TResult Function()? timerDataNotFound,
    TResult Function(String status)? unexpected,
    required TResult orElse(),
  }) {
    if (groupNotFound != null) {
      return groupNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntryNotFound value) entryNotFound,
    required TResult Function(TimeRangesOverlap value) timeRangesOverlap,
    required TResult Function(ProjectNotFound value) projectNotFound,
    required TResult Function(GroupNotFound value) groupNotFound,
    required TResult Function(MultipleTimerStarts value) multipleTimerStarts,
    required TResult Function(TimerDataNotFound value) timerDataNotFound,
    required TResult Function(Unexpected value) unexpected,
  }) {
    return groupNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntryNotFound value)? entryNotFound,
    TResult? Function(TimeRangesOverlap value)? timeRangesOverlap,
    TResult? Function(ProjectNotFound value)? projectNotFound,
    TResult? Function(GroupNotFound value)? groupNotFound,
    TResult? Function(MultipleTimerStarts value)? multipleTimerStarts,
    TResult? Function(TimerDataNotFound value)? timerDataNotFound,
    TResult? Function(Unexpected value)? unexpected,
  }) {
    return groupNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntryNotFound value)? entryNotFound,
    TResult Function(TimeRangesOverlap value)? timeRangesOverlap,
    TResult Function(ProjectNotFound value)? projectNotFound,
    TResult Function(GroupNotFound value)? groupNotFound,
    TResult Function(MultipleTimerStarts value)? multipleTimerStarts,
    TResult Function(TimerDataNotFound value)? timerDataNotFound,
    TResult Function(Unexpected value)? unexpected,
    required TResult orElse(),
  }) {
    if (groupNotFound != null) {
      return groupNotFound(this);
    }
    return orElse();
  }
}

abstract class GroupNotFound implements CustomAppException {
  const factory GroupNotFound() = _$GroupNotFoundImpl;
}

/// @nodoc
abstract class _$$MultipleTimerStartsImplCopyWith<$Res> {
  factory _$$MultipleTimerStartsImplCopyWith(_$MultipleTimerStartsImpl value,
          $Res Function(_$MultipleTimerStartsImpl) then) =
      __$$MultipleTimerStartsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MultipleTimerStartsImplCopyWithImpl<$Res>
    extends _$CustomAppExceptionCopyWithImpl<$Res, _$MultipleTimerStartsImpl>
    implements _$$MultipleTimerStartsImplCopyWith<$Res> {
  __$$MultipleTimerStartsImplCopyWithImpl(_$MultipleTimerStartsImpl _value,
      $Res Function(_$MultipleTimerStartsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MultipleTimerStartsImpl implements MultipleTimerStarts {
  const _$MultipleTimerStartsImpl();

  @override
  String toString() {
    return 'CustomAppException.multipleTimerStarts()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MultipleTimerStartsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() entryNotFound,
    required TResult Function() timeRangesOverlap,
    required TResult Function() projectNotFound,
    required TResult Function() groupNotFound,
    required TResult Function() multipleTimerStarts,
    required TResult Function() timerDataNotFound,
    required TResult Function(String status) unexpected,
  }) {
    return multipleTimerStarts();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? entryNotFound,
    TResult? Function()? timeRangesOverlap,
    TResult? Function()? projectNotFound,
    TResult? Function()? groupNotFound,
    TResult? Function()? multipleTimerStarts,
    TResult? Function()? timerDataNotFound,
    TResult? Function(String status)? unexpected,
  }) {
    return multipleTimerStarts?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? entryNotFound,
    TResult Function()? timeRangesOverlap,
    TResult Function()? projectNotFound,
    TResult Function()? groupNotFound,
    TResult Function()? multipleTimerStarts,
    TResult Function()? timerDataNotFound,
    TResult Function(String status)? unexpected,
    required TResult orElse(),
  }) {
    if (multipleTimerStarts != null) {
      return multipleTimerStarts();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntryNotFound value) entryNotFound,
    required TResult Function(TimeRangesOverlap value) timeRangesOverlap,
    required TResult Function(ProjectNotFound value) projectNotFound,
    required TResult Function(GroupNotFound value) groupNotFound,
    required TResult Function(MultipleTimerStarts value) multipleTimerStarts,
    required TResult Function(TimerDataNotFound value) timerDataNotFound,
    required TResult Function(Unexpected value) unexpected,
  }) {
    return multipleTimerStarts(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntryNotFound value)? entryNotFound,
    TResult? Function(TimeRangesOverlap value)? timeRangesOverlap,
    TResult? Function(ProjectNotFound value)? projectNotFound,
    TResult? Function(GroupNotFound value)? groupNotFound,
    TResult? Function(MultipleTimerStarts value)? multipleTimerStarts,
    TResult? Function(TimerDataNotFound value)? timerDataNotFound,
    TResult? Function(Unexpected value)? unexpected,
  }) {
    return multipleTimerStarts?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntryNotFound value)? entryNotFound,
    TResult Function(TimeRangesOverlap value)? timeRangesOverlap,
    TResult Function(ProjectNotFound value)? projectNotFound,
    TResult Function(GroupNotFound value)? groupNotFound,
    TResult Function(MultipleTimerStarts value)? multipleTimerStarts,
    TResult Function(TimerDataNotFound value)? timerDataNotFound,
    TResult Function(Unexpected value)? unexpected,
    required TResult orElse(),
  }) {
    if (multipleTimerStarts != null) {
      return multipleTimerStarts(this);
    }
    return orElse();
  }
}

abstract class MultipleTimerStarts implements CustomAppException {
  const factory MultipleTimerStarts() = _$MultipleTimerStartsImpl;
}

/// @nodoc
abstract class _$$TimerDataNotFoundImplCopyWith<$Res> {
  factory _$$TimerDataNotFoundImplCopyWith(_$TimerDataNotFoundImpl value,
          $Res Function(_$TimerDataNotFoundImpl) then) =
      __$$TimerDataNotFoundImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TimerDataNotFoundImplCopyWithImpl<$Res>
    extends _$CustomAppExceptionCopyWithImpl<$Res, _$TimerDataNotFoundImpl>
    implements _$$TimerDataNotFoundImplCopyWith<$Res> {
  __$$TimerDataNotFoundImplCopyWithImpl(_$TimerDataNotFoundImpl _value,
      $Res Function(_$TimerDataNotFoundImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TimerDataNotFoundImpl implements TimerDataNotFound {
  const _$TimerDataNotFoundImpl();

  @override
  String toString() {
    return 'CustomAppException.timerDataNotFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TimerDataNotFoundImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() entryNotFound,
    required TResult Function() timeRangesOverlap,
    required TResult Function() projectNotFound,
    required TResult Function() groupNotFound,
    required TResult Function() multipleTimerStarts,
    required TResult Function() timerDataNotFound,
    required TResult Function(String status) unexpected,
  }) {
    return timerDataNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? entryNotFound,
    TResult? Function()? timeRangesOverlap,
    TResult? Function()? projectNotFound,
    TResult? Function()? groupNotFound,
    TResult? Function()? multipleTimerStarts,
    TResult? Function()? timerDataNotFound,
    TResult? Function(String status)? unexpected,
  }) {
    return timerDataNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? entryNotFound,
    TResult Function()? timeRangesOverlap,
    TResult Function()? projectNotFound,
    TResult Function()? groupNotFound,
    TResult Function()? multipleTimerStarts,
    TResult Function()? timerDataNotFound,
    TResult Function(String status)? unexpected,
    required TResult orElse(),
  }) {
    if (timerDataNotFound != null) {
      return timerDataNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntryNotFound value) entryNotFound,
    required TResult Function(TimeRangesOverlap value) timeRangesOverlap,
    required TResult Function(ProjectNotFound value) projectNotFound,
    required TResult Function(GroupNotFound value) groupNotFound,
    required TResult Function(MultipleTimerStarts value) multipleTimerStarts,
    required TResult Function(TimerDataNotFound value) timerDataNotFound,
    required TResult Function(Unexpected value) unexpected,
  }) {
    return timerDataNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntryNotFound value)? entryNotFound,
    TResult? Function(TimeRangesOverlap value)? timeRangesOverlap,
    TResult? Function(ProjectNotFound value)? projectNotFound,
    TResult? Function(GroupNotFound value)? groupNotFound,
    TResult? Function(MultipleTimerStarts value)? multipleTimerStarts,
    TResult? Function(TimerDataNotFound value)? timerDataNotFound,
    TResult? Function(Unexpected value)? unexpected,
  }) {
    return timerDataNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntryNotFound value)? entryNotFound,
    TResult Function(TimeRangesOverlap value)? timeRangesOverlap,
    TResult Function(ProjectNotFound value)? projectNotFound,
    TResult Function(GroupNotFound value)? groupNotFound,
    TResult Function(MultipleTimerStarts value)? multipleTimerStarts,
    TResult Function(TimerDataNotFound value)? timerDataNotFound,
    TResult Function(Unexpected value)? unexpected,
    required TResult orElse(),
  }) {
    if (timerDataNotFound != null) {
      return timerDataNotFound(this);
    }
    return orElse();
  }
}

abstract class TimerDataNotFound implements CustomAppException {
  const factory TimerDataNotFound() = _$TimerDataNotFoundImpl;
}

/// @nodoc
abstract class _$$UnexpectedImplCopyWith<$Res> {
  factory _$$UnexpectedImplCopyWith(
          _$UnexpectedImpl value, $Res Function(_$UnexpectedImpl) then) =
      __$$UnexpectedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String status});
}

/// @nodoc
class __$$UnexpectedImplCopyWithImpl<$Res>
    extends _$CustomAppExceptionCopyWithImpl<$Res, _$UnexpectedImpl>
    implements _$$UnexpectedImplCopyWith<$Res> {
  __$$UnexpectedImplCopyWithImpl(
      _$UnexpectedImpl _value, $Res Function(_$UnexpectedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
  }) {
    return _then(_$UnexpectedImpl(
      null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UnexpectedImpl implements Unexpected {
  const _$UnexpectedImpl(this.status);

  @override
  final String status;

  @override
  String toString() {
    return 'CustomAppException.unexpected(status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnexpectedImpl &&
            (identical(other.status, status) || other.status == status));
  }

  @override
  int get hashCode => Object.hash(runtimeType, status);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnexpectedImplCopyWith<_$UnexpectedImpl> get copyWith =>
      __$$UnexpectedImplCopyWithImpl<_$UnexpectedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() entryNotFound,
    required TResult Function() timeRangesOverlap,
    required TResult Function() projectNotFound,
    required TResult Function() groupNotFound,
    required TResult Function() multipleTimerStarts,
    required TResult Function() timerDataNotFound,
    required TResult Function(String status) unexpected,
  }) {
    return unexpected(status);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? entryNotFound,
    TResult? Function()? timeRangesOverlap,
    TResult? Function()? projectNotFound,
    TResult? Function()? groupNotFound,
    TResult? Function()? multipleTimerStarts,
    TResult? Function()? timerDataNotFound,
    TResult? Function(String status)? unexpected,
  }) {
    return unexpected?.call(status);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? entryNotFound,
    TResult Function()? timeRangesOverlap,
    TResult Function()? projectNotFound,
    TResult Function()? groupNotFound,
    TResult Function()? multipleTimerStarts,
    TResult Function()? timerDataNotFound,
    TResult Function(String status)? unexpected,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected(status);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntryNotFound value) entryNotFound,
    required TResult Function(TimeRangesOverlap value) timeRangesOverlap,
    required TResult Function(ProjectNotFound value) projectNotFound,
    required TResult Function(GroupNotFound value) groupNotFound,
    required TResult Function(MultipleTimerStarts value) multipleTimerStarts,
    required TResult Function(TimerDataNotFound value) timerDataNotFound,
    required TResult Function(Unexpected value) unexpected,
  }) {
    return unexpected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntryNotFound value)? entryNotFound,
    TResult? Function(TimeRangesOverlap value)? timeRangesOverlap,
    TResult? Function(ProjectNotFound value)? projectNotFound,
    TResult? Function(GroupNotFound value)? groupNotFound,
    TResult? Function(MultipleTimerStarts value)? multipleTimerStarts,
    TResult? Function(TimerDataNotFound value)? timerDataNotFound,
    TResult? Function(Unexpected value)? unexpected,
  }) {
    return unexpected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntryNotFound value)? entryNotFound,
    TResult Function(TimeRangesOverlap value)? timeRangesOverlap,
    TResult Function(ProjectNotFound value)? projectNotFound,
    TResult Function(GroupNotFound value)? groupNotFound,
    TResult Function(MultipleTimerStarts value)? multipleTimerStarts,
    TResult Function(TimerDataNotFound value)? timerDataNotFound,
    TResult Function(Unexpected value)? unexpected,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected(this);
    }
    return orElse();
  }
}

abstract class Unexpected implements CustomAppException {
  const factory Unexpected(final String status) = _$UnexpectedImpl;

  String get status;
  @JsonKey(ignore: true)
  _$$UnexpectedImplCopyWith<_$UnexpectedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
